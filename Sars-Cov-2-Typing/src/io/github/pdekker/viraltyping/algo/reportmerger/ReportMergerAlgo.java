package io.github.pdekker.viraltyping.algo.reportmerger;

import java.util.Date;
import java.util.List;
import java.util.Set;

import com.clcbio.api.base.algorithm.Algo;
import com.clcbio.api.base.algorithm.AlgoException;
import com.clcbio.api.base.algorithm.AlgoHistoryTools;
import com.clcbio.api.base.algorithm.AlgoWarningException;
import com.clcbio.api.base.algorithm.CallableExecutor;
import com.clcbio.api.base.algorithm.ChannelDescription;
import com.clcbio.api.base.algorithm.KnownEndIterator;
import com.clcbio.api.base.algorithm.Multiplicity;
import com.clcbio.api.base.algorithm.OutputHandler;
import com.clcbio.api.base.algorithm.parameter.AlgoParameters;
import com.clcbio.api.base.algorithm.resource.NonExclusive;
import com.clcbio.api.base.framework.ProgramInfo;
import com.clcbio.api.base.math.misc.Target;
import com.clcbio.api.base.session.ApplicationContext;
import com.clcbio.api.base.util.CreateList;
import com.clcbio.api.clc.datatypes.report.ReportCompositeElement;
import com.clcbio.api.clc.datatypes.report.ReportFrontPageStringElement;
import com.clcbio.api.clc.datatypes.report.ReportGraphicsElement;
import com.clcbio.api.clc.datatypes.report.ReportStringElement;
import com.clcbio.api.clc.datatypes.report.ReportStructuredTableElement;
import com.clcbio.api.clc.datatypes.report.ReportTableElement;
import com.clcbio.api.clc.datatypes.report.ReportTextElement;
import com.clcbio.api.clc.datatypes.report.SimpleReport;
import com.clcbio.api.free.datatypes.ClcObject;
import com.clcbio.api.free.datatypes.report.Report;
import com.clcbio.api.free.datatypes.report.ReportElement;

@NonExclusive(minThreads = 1, maxThreads = -1)
public class ReportMergerAlgo extends Algo {

	public static final String ID = "sars_cov2_report_merger";
	public static final double VERSION = 1.1;
	public static final String NAME = "Merge Reports";
	public static long algoVersionUID = 318610238L;

	public static final ChannelDescription<Report> INPUT_CHANNEL = ChannelDescription.create("Report", Report.class,
			"report-input", Multiplicity.AT_LEAST_TWO);
	public static final ChannelDescription<Report> OUTPUT_CHANNEL = ChannelDescription.create("Merged Report",
			Report.class, "report-output");

	public ReportMergerAlgo(final ApplicationContext applicationContext) {
		super(applicationContext);
		addInputChannel(INPUT_CHANNEL.createDefaultInputChannel());
		addOutputChannel(OUTPUT_CHANNEL.createDefaultOutputChannel());
	}

	@Override
	public void alignParametersToChannelUse(Set<? extends ChannelDescription<?>> usedChannels,
			Target<String> alignmentProblems) {
		super.alignParametersToChannelUse(usedChannels, alignmentProblems);
	}

	@Override
	public void checkParametersAndInput(Target<String> problems) {
		super.checkParametersAndInput(problems);
		if (getInputObjectsCount() < 1) {
			problems.put("Select at least one report");
		}
	}

	@Override
	public void calculate(final OutputHandler handler, final CallableExecutor objectModificationExecutor)
			throws AlgoException, InterruptedException {

		final List<ReportElement> elements = CreateList.of();
		final ReportMergerInterpreter p = getInterpreter(getParameters());
		final boolean includefrontPage = p.createFrontPage.get();

		final List<String> captions = p.elements.getAll();

		for (final String caption : captions) {
			final ReportElement re = createCopy(caption);
			if (re == null) {
				handler.postMessage("'" + caption + "' not found in reports", this);
			} else {
				elements.add(re);
			}
		}
		if (includefrontPage) {
			elements.add(new ReportFrontPageStringElement(
					"Generated by: " + getApplicationContext().getUserContext().getUsername()));
			elements.add(new ReportFrontPageStringElement("Date: " + new Date()));
			elements.add(new ReportFrontPageStringElement(
					"Software: " + ProgramInfo.getProductName() + " " + ProgramInfo.getShortVersionString()));
		}

		final Report merged = new SimpleReport(elements, null);
		merged.startNoUndoBlock();
		merged.setName("Report");
		merged.addHistory(AlgoHistoryTools.createEnrichedEntry(merged, this));
		merged.endNoUndoBlock();
		handler.postOutputObjects(merged, this);
		postToChannel(OUTPUT_CHANNEL, merged);
	}

	private ReportElement createCopy(String caption) throws AlgoWarningException {
		final KnownEndIterator<? extends ClcObject> it = getInputObjectsIterator();
		while (it.hasNext()) {
			final ClcObject o = it.next();
			if (o instanceof Report) {
				final Report report = (Report) o;
				for (final ReportElement re : report.getReportElements()) {
					if (re instanceof ReportFrontPageStringElement) {
						continue; // we can only have 1 frontpage..
					}
					final ReportElement reCopy = createCopy(re, caption);
					if (reCopy != null) {
						return reCopy;
					}
				}
			}
		}
		return null;

	}

	private ReportElement createCopy(ReportElement re, String caption) throws AlgoWarningException {
		if (re instanceof ReportFrontPageStringElement) {
			return null; // we don't copy frontpages but create a new one.
		}
		if (re instanceof ReportStringElement) {
			return new ReportStringElement(((ReportStringElement) re).getContent());
		}
		if (re instanceof ReportTextElement) {
			return new ReportTextElement(((ReportTextElement) re).getContent());
		}
		if (re instanceof ReportGraphicsElement) {
			return copyGraphicsElement((ReportGraphicsElement) re);
		}
		if (re instanceof ReportTableElement) {
			return copyTableElement((ReportTableElement) re);
		}
		if (re instanceof ReportStructuredTableElement) {
			return copyStructuredTableElement((ReportStructuredTableElement) re);
		}
		if (re instanceof ReportCompositeElement) {
			final ReportCompositeElement rce = (ReportCompositeElement) re;
			if (caption == null || caption.equals(rce.getCaption())) {

				final ReportCompositeElement copy = new ReportCompositeElement();
				copy.setCaption(rce.getCaption());
				for (final ReportElement innerElement : rce.getReportElements()) {
					copy.addReportElement(createCopy(innerElement, null));
				}
				return copy;
			} else {
				return null;
			}
		}
		throw new AlgoWarningException("Found unknown report element: " + re.getClass().getCanonicalName());
	}

	private ReportElement copyStructuredTableElement(ReportStructuredTableElement re) {
		return new ReportStructuredTableElement(re.getIdentifier(), re.getTable(), re.getPrintMaxColumns(),
				re.isPrintRepeatLeftColumn());
	}

	private ReportElement copyTableElement(ReportTableElement re) {
		return new ReportTableElement(re.getTable(), re.getCaption(), re.isLeftColumnFixed());
	}

	private ReportElement copyGraphicsElement(ReportGraphicsElement re) {
		final ClcObject obj = re.getOriginLink();
		return new ReportGraphicsElement(obj.createObject());
	}

	@Override
	public String getName() {
		return NAME;
	}

	@Override
	public String getClassKey() {
		return ID;

	}

	@Override
	public double getVersion() {
		return VERSION;
	}

	@Override
	protected ReportMergerInterpreter getInterpreter(AlgoParameters parameters) {
		return new ReportMergerInterpreter(parameters);
	}

}
